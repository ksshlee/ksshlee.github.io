---
title: 알고리즘 - 분할 정복, 퀵 정렬, 합병 정렬(Divide and Conquer)
categories : [알고리즘]
tags: [알고리즘,퀵 정렬, 합병 정렬, 정렬]
toc: true
toc_sticky: true
toc_label: "목차"
---

분할 정복이란
-
- 하나의 큰 문제를 쪼개서 푸는 알고리즘이다.
- 즉 문제를 분리하여 나눈후 문제를 해결하면서 합병하는 알고리즘이다.
- 평균적으로 시간 복잡도는 O(nlogn) 이다.


**장점**
- 어려운 문제를 나누면 조금은 더 쉽게 해결할 수 있다는 엄청난 장점이 있다.
- 병렬적으로 문제를 해결한다.


**단점**
- 함수를 재귀적으로 호출함으로써 함수 호출로 인한 오버헤드가 발생한다.
- 합병 정렬 같은 경우 합병을 위해 추가적인 메모리가 필요하다 즉 과도한 메모리 사용을 하게 된다.
  - 스택 오버플로우가 발생할수도 있다.

<br><br>




분할 사용 예시
-

### 정렬




#### 합병 정렬 (Merge sort)

![merge](/assets/img/al_lib/2020-10-07/merge.gif)

**특징**

- O(nlogn) 의 시간복잡도와 O(n)의 공간 복잡도를 갖는다.
- *속도면에선 효율적이지만 정렬 과정에서 n의 공간이 필요 하므로 오버플로우가 발생할 수 있다.*
- 안정 정렬에 속한다.

**수도 코드**

```java
divide(int[] num, start, end){
    if(start<end){
        mid = (start + end) / 2
        divide(num,start,mid);
        divide(num,mid+1,end);
        merge(num,start,mid,end);
    }
}

merge(int[] num, start, mid, end){
  i = start
  j = mid+1

  index = 0

  int[] tmp

  while(i<=mid && j<=end){
    if(num[i]<num[j]){
      tmp[index++] = num[i]
      i++
    }else{
      tmp[index++] = num[j]
      j++
    }
  }

  if(i>mid){
    for(x = j; x <= end; x++){
      tmp[index++] = num[x]
    }
  }else{
    for(x = i; x <= mid; x++){
      tmp[index++] = num[x]
    }
  }

  for(x = start; x <= end; x++){
    num[x] = tmp[x]
  }

}
```


#### 퀵 정렬 (Quick sort)

![quick](/assets/img/al_lib/2020-10-07/quick.gif)

**특징**

- 퀵 정렬은 **불안정 정렬**에 속하며 동시에 비교 정렬에 속한다.
- 평균적으로 매우 빠른 수행 속도를 자랑한다.
- 시간복잡도는 평균 O(nlogn) 이다.
- **최악의 경우는 O(n^2)이다.**
  - 이미 정렬된 리스트에 대하여 퀵 정렬을 실행하는 경우

**수도코드**

```java
divide(int[] num, start, end){
    if(start<end){
        pivot = partition(num, start, end)
        divide(num,start,pivot-1);
        divide(num,pivot+1,end);
    }
}

partition(int[] num, start, end){
  i = start + 1
  j = high

  while(i<=j){
    if(num[i] <= num[start]){
      i++
    }else if(num[j] >= num[start]){
      j--
    }else{
      tmp = num[i]
      num[i] = num[j]
      num[j] = tmp
      i++
      j--
    }
  }

  tmp = num[low]
  num[low] = num[j]
  num[j] = tmp

  return j

}
```






<br><br>



출처
-

[https://janghw.tistory.com/entry/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Divide-and-Conquer-%EB%B6%84%ED%95%A0%EC%A0%95%EB%B3%B5](https://janghw.tistory.com/entry/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Divide-and-Conquer-%EB%B6%84%ED%95%A0%EC%A0%95%EB%B3%B5)

[https://kimch3617.tistory.com/entry/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B6%84%ED%95%A0%EC%A0%95%EB%B3%B5%EB%B2%95-Divide-and-Conquer](https://kimch3617.tistory.com/entry/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B6%84%ED%95%A0%EC%A0%95%EB%B3%B5%EB%B2%95-Divide-and-Conquer)

[https://gmlwjd9405.github.io/2018/05/10/algorithm-quick-sort.html](https://gmlwjd9405.github.io/2018/05/10/algorithm-quick-sort.html)



<br><br>



**혹시 제가 잘못 알고 있거나 오타, 궁금한점 있으시면 댓글 남겨주시면 감사겠습니다!**
