<!DOCTYPE html>
<html class="no-js">
  <head>
	<meta charset="utf-8">
	<title>Search | Dev_Hyuk</title>
	<meta name="description"
		content="Hyuk의 기술블로그">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<!-- CSS -->
	<link rel="stylesheet" href="/assets/css/main.css">
	<!-- bootstrap -->
	<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
	<script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
	<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
	<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>
	
	<!-- syntax.css -->
	<link rel="stylesheet" href="/assets/css/syntax.css">

	<!--Favicon-->
	<link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon">

	<!-- Canonical -->
	<link rel="canonical" href="/search.html">

	<!-- RSS -->
	<!-- <link rel="alternate" type="application/atom+xml" title="Dev_Hyuk"
		href="/feed.xml" /> -->
	<link rel="alternate" type="application/atom+xml" title="Dev_Hyuk" href="/feed.xml" />

	<!-- Font Awesome -->
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css"
		integrity="sha384-oS3vJWv+0UjzBfQzYUhtDYW+Pj2yciDJxpsK1OYPAYjqT085Qq/1cq5FLXAZQ7Ay" crossorigin="anonymous">

	<!-- Google Fonts -->
	
	<link href="//fonts.googleapis.com/css?family=Nanum+Gothic:400,700" rel="stylesheet"
		type="text/css">
	

	<!-- KaTeX -->
	

	<!-- Google Analytics -->
	
</head>
  <body>
    <header class="site-header">
	<div class="branding">
			<div style="float: right;">
					<nav class="navbar navbar-expand-lg navbar-light bg-light rounded">
							<a class="navbar-brand" target="_blank" href="https://www.notion.so/ksshlee/Sang-Hyuk-Lee-d0d25ccd294146588514095fadc7f477">
								<img src="/assets/img/avatar.png" width="30" height="30" class="d-inline-block align-top" alt="">
								Dev_Hyuk
							</a>
							<button class="navbar-toggler collapsed" type="button" data-toggle="collapse" data-target="#navbarsExample09" aria-controls="navbarsExample09" aria-expanded="false" aria-label="Toggle navigation">
							  <span class="navbar-toggler-icon"></span>
							</button>
						
							<div class="navbar-collapse collapse" id="navbarsExample09" style>
							  <ul class="navbar-nav mr-auto">
								<li class="nav-item active">
								  <a class="nav-link" href="/">Home <span class="sr-only">(current)</span></a>
								</li>
								<li class="nav-item dropdown">
										<a class="nav-link dropdown-toggle" data-toggle="dropdown" href="#" role="button" aria-haspopup="true" aria-expanded="false">Algorithm</a>
										<div class="dropdown-menu">
										  <a class="dropdown-item" href="/Algorithm/AL_Library">라이브러리</a>
										  <a class="dropdown-item" href="/Algorithm/AL_Problem">문제풀이</a>
										</div>
									  </li>
						  
						  
									  <li class="nav-item dropdown">
										  <a class="nav-link dropdown-toggle" data-toggle="dropdown" href="#" role="button" aria-haspopup="true" aria-expanded="false">Data Structure</a>
										  <div class="dropdown-menu">
											<a class="dropdown-item" href="/Data_Structure/DS_Library">라이브러리</a>
											<!-- <a class="dropdown-item" href="/Data_Structure/DS_USE">활용</a> -->
										  </div>
									  </li>
						  
						  
									  <li class="nav-item dropdown">
										  <a class="nav-link dropdown-toggle" data-toggle="dropdown" href="#" role="button" aria-haspopup="true" aria-expanded="false">Web</a>
										  <div class="dropdown-menu">
											  <!-- <a class="dropdown-item" href="/Web/Front_End">프론트 엔드</a> -->
											  <a class="dropdown-item" href="/Web/Back_End">백 엔드</a>
										  </div>
									  </li>
						  
						  
									  <!-- 추후 시큐어코딩 공부시작하면 -->
									  <!-- <li class="nav-item dropdown">
									  <a class="nav-link dropdown-toggle" data-toggle="dropdown" href="#" role="button" aria-haspopup="true" aria-expanded="false">Security</a>
									  <div class="dropdown-menu">
										  <a class="dropdown-item" href="/Security/Secure Coding">시큐어 코딩</a>
										  <div class="dropdown-divider"></div>
										  <a class="dropdown-item" href="#">Separated link</a>
									  </div>
									  </li> -->
						  
									  <!-- <li class="nav-item dropdown">
											  <a class="nav-link dropdown-toggle" data-toggle="dropdown" href="#" role="button" aria-haspopup="true" aria-expanded="false">Others</a>
											  <div class="dropdown-menu">
												  <a class="dropdown-item" href="/Others/Git">Git</a>
												  <a class="dropdown-item" href="/Others/Docker">Docker</a>
												  <a class="dropdown-item" href="/Others/Linux">Linux</a>
												  <a class="dropdown-item" href="/Others/Elk">Elk</a>
											  </div>
									  </li> -->

									  <li class="nav-item">
										<a class="nav-link active" href="/Programming_Tips">Programming Tips</a>
									  </li>
						  
									  <li class="nav-item">
										  <a class="nav-link active" target="_blank" href="https://www.notion.so/ksshlee/Sang-Hyuk-Lee-d0d25ccd294146588514095fadc7f477">About me</a>
									  </li>
								</ul>
							</div>
					</nav>
				</div>
				
	</div>


</header>

    <div class="content">
      <article >
  <header style="background-image: url('/')">
    <h1 class="title">Search</h1>
      
  </header>
  <section class="post-content"><div class="search">
    <div id="search-results"></div>
    <p id="not-found" style="display: none">
        No results found.
    </p>
</div>


<script>
  window.store = {
    
      "eb-b0-b1-ec-97-94-eb-93-9c-2020-01-09-mysqlddl-html": {
        "title": "MySQL DDL 기본 사용법",
        "tags": "Mysql, MySQL, SQL, DB, database, backend, DDL",
        "date": "January 9, 2020",
        "author": "",
        "category": "",
        "content": "목차DDLDatabase 생성하기Database 조회하고, 사용하기Database 삭제하기TableTable 생성하기Table 삭제하기Table 수정하기Table 초기화DDL (Data Definition Language)  데이터 정의어  데이터들은 변경이 불가능하다.  Database, table을 생성, 수정, 삭제할 수 있다.Database 생성하기  Databse를 생성하는 명령어의 구조CREATE DATABASE dbname;  사실 대문자 소문자 상관없다.  Profile이라는 이름을 갖는 DB 생성  Qeury OK, 이런 문구가 뜬다면 성공했다.  그러면 MySQL 안에 Profile이라는 이름을 갖은 Profile이 생성된 것이다.Database 조회하고, 사용하기  현재 서버에 생성되어 있는 DB를 조회하고 싶다면 다음 명령어를 사용하면 된다.SHOW databases;  그러면 이렇게 현재 존재하는 DB들을 볼수 있다.  현재 DB 현황을 표현한 것이다.USE dbname;  명령어를 통하여 해당 db를 사용할 수 있다.  그러면 Profile이라는 DB를 사용한다라는 뜻이 되고 그림으로 위와 같이 표현할 수 있다.Database 삭제하기  Databse를 삭제하는 명령어 구조DROP DATABASE IF EXISTS dbname;  IF EXISTS는 제거해도 된다.  이 문구가 없다면 오류가 발생하여 오류를 보기 싫은 분들은 IF EXITST 를 추가해주도록 하자  사용했을 때와 사용하지 않았을 때의 차이다.Table  테이블을 간단하게 묘사한 그림이다.  빨간색으로 감싸진 부분들을 컬럼(column)이라고 생각하면 된다.create table tbname(\tcolname1 datatype [NULL | NOT NULL][DEFAULT][AUTO_INCREMENT],\tcolname2 datatype [NULL | NOT NULL][DEFAULT][AUTO_INCREMENT],\tPRIMARY KEY (colname));  다음과 같은 명령어로 테이블을 생성할 수 있다.  []안에 감싸진 것은 옵션이다. 사용해도 되고 안해도 지장이 없다.  colname 은 컬럼명을 적어준다.  datatype은 해당 컬럼에서 사용할 자료형을 선택하는 것이다.  [ NULL NOT NULL] 은 해당 컬럼을 null값을 허용하는지를 선택한다. 빈값 허용은 NULL 반대는 NOT NULL이다. (단 해당 컬럼이 primary key 면 NOT NULL 이 default 이다.)  [ DEFAULT] 키워드와 함께 입력하지 않았을때의 초기값을 설정해줄 수 있다.  [ AUTO_INCREMENT] 따로 입력하지 않으면 자동으로 값이 1씩 증가하게 설정할 수 있다.datatype      숫자        문자  Table 생성하기  pID, name, age 는 필수로 입력해야 하는 값이다.  Profile DB에 profile이라는 table을 생성한것을 표현했다.Table 삭제하기DROP TABLE IF EXISTS tbname;  IF EXISTS는 옵션이다.Table 수정하기새로운 컬럼 추가ALTER TABLE colname ADD COLUMN new colname col option;ex) ALTER TABLE profile ADD COLUMN height INT NOT NULL;  height라는 칼럼이 추가된 것을 확인할 수 있다.컬럼 구조 수정ALTER TABLE tbname MODIFY COLUMN colname col option;ex) ALTER TABLE Profile MODIFY COLUMN pID INT NOT NULL PRIMARY KEY;  pID 컬럼에 Key에 PRI 즉 pID값이 Primary key로 수정된것을 확인할 수 있다.컬럼 삭제ALTER TABLE tbname DROP COLUMN colname;ex) ALTER TABLE Profile DROP COLUMN height;  height 컬럼이 삭제된 것을 확인할 수 있다.Table 초기화TRUNCATE TABLE tbname;ex) TRUNCATE TABLE profile;  테이블 설정(정의)는 남겨놓고 모든 데이터를 삭제하는 명령어 입니다.출처https://victorydntmd.tistory.com/136https://server-talk.tistory.com/159https://www.fun-coding.org/mysql_basic3.html혹시 제가 잘못 알고 있거나 오타, 궁금한점 있으시면 댓글 남겨주시면 감사하겠습니다!",
        "url": "//%EB%B0%B1%EC%97%94%EB%93%9C/2020/01/09/MySQLDDL.html"
      }
      ,
    
      "eb-b0-b1-ec-97-94-eb-93-9c-2020-01-08-mysql-html": {
        "title": "MySQL 설치, 실행, 종료, 접속 방법",
        "tags": "Mysql, MySQL, SQL, DB, database, backend",
        "date": "January 8, 2020",
        "author": "",
        "category": "",
        "content": "목차SQL 이란?Mac에서 MySQL 설치하기MySQL 간단 사용법SQL(Structured Query Language) 이란?  SQL은 관계형 데이터베이스 관리 시스템의 데이터를 관리하기 위해 설계된 프로그래밍 언어이다.  SQL로 데이터베이스에 질의를 보낼 수 있다.  데이터베이스로부터 데이터를 조회,수정,삭제 할 수 있다.  새로운 데이터베이스를 생성할 수 있다.💻 Mac에서 MySQL 설치하기  우선 HomeBrew가 있다면 MySQL 설치는 정말 쉽다.brew install mysql  이렇게 실행하고 오류가 없었다면 정상적으로 설치가 된 것이다.MySQL 간단 사용법      MySQL 실행하기  mysql.server start  이런 창이 뜬다면 실행 성공 너무 간단하다.      MySQL 종료하기  mysql.server stop  명령어로 MySQL을 종료시킬 수 있다.      MySQL 데몬 실행하기  데몬 실행이란?  처음 가동될 때 실행되는 백그라운드 프로세스의 일종      메모리에 상주하다가 요청이 오면 대응 할 수 있게 항상 대기 중인 프로세스    데몬으로 실행하기brew services start mysqlbrew services list  brew services list는 현재 데몬으로 구동중인 서비스들 목록을 확인 할 수 있는 명령어이다.      MySQL 데몬 재시작하기  brew services restart mysql  위의 명령어를 통하여 재실행이 가능하다.      MySQL 데몬 종료하기  brew services stop mysqlbrew services list  마지막 명령어로 제대로 종료되었는지 확인할수 있다.MySQL 접속방법출처https://m.blog.naver.com/PostView.nhn?blogId=angkeloss&amp;logNo=220070830538&amp;proxyReferer=https%3A%2F%2Fwww.google.com%2Fhttps://ourcstory.tistory.com/30혹시 제가 잘못 알고 있거나 오타, 궁금한점 있으시면 댓글 남겨주시면 감사하겠습니다!",
        "url": "//%EB%B0%B1%EC%97%94%EB%93%9C/2020/01/08/MySql.html"
      }
      ,
    
      "ed-94-84-eb-a1-9c-ea-b7-b8-eb-9e-98-eb-b0-8d-20tips-2020-01-03-json-ed-8c-8c-ec-8b-b1-ed-95-98-ea-b8-b0-html": {
        "title": "JSON파일 파싱",
        "tags": "json, 파싱, Java, Python",
        "date": "January 3, 2020",
        "author": "",
        "category": "",
        "content": "목차    JSON 이란?    JSON 파싱 with Python    JSON 파일 만들기 Python    Java로 JSON파싱 환경 설정하기    JSON 파싱하기 with JavaJSON (JavaScript Object NOtation) 이란?JSON은 간단하게 말해 사람이 읽고 쓰기에 용이하고, 기계가 분석하고 생성함에도 용이한 문자 기반의 데이터 포맷이다.원래는 JavaScript 언어로부터 파생되었다.JSON은 프로그래밍 언어와 운영체제에서 독립적이다.JSON 객체   JSON 객체는 중괄호({})로 둘러 쌓아서 표현한다.{    \"name\" : \"이상혁\",    \"age\" : 24,    \"hobby\" : \"programming\",    \"job\" : \"student\"}  객체 안에 객체도 가능하다.{    \"name\" : \"이상혁\",    \"age\" : 24,    \"hobby\" : \"programming\",    \"job\" : \"student\",    \"father\" : {        \"name\" : \"이00\"    },    \"mother\" : {        \"name\" : \"김00\"    },    \"sister\" : {        \"name\" : \"이00\"    },    \"skill\" : [\"Java\",\"Python\",\"Git\"]    }JSON 배열   JSON 배열은 대괄호([])로 둘러 쌓아서 표현한다.\"skills\":[    {\"name\" : \"Java\", \"level\" : 2},    {\"name\" : \"Python\", \"level\" : 3},    {\"name\" : \"JavaScript\", \"level\" : 2}]or\"skills\":[    \"Java\",    \"Python\",    \"JavaScript\"]JSON 파싱 with Python*파이썬에서 JSON 파싱은 너무 간단한 작업이다.JSON은 아래의 예시로 하겠다.{    \"name\" : \"이상혁\",    \"age\" : 24,    \"hobby\" : \"programming\",    \"job\" : \"student\",    \"father\" : {        \"name\" : \"이00\"    },    \"mother\" : {        \"name\" : \"김00\"    },    \"sister\" : {        \"name\" : \"이00\"    },    \"skill\" : [\"Java\",\"Python\",\"Git\"]    }  Python 파싱 코드import jsonwith open('json파일의 위치') as json_file:    json_data = json.load(json_file)    json_value = json_data['key값']    print(json_value)간단하게 JSON파일은 python으로 파싱할시 dict형태로 파싱이 된다.그러면 dict에서 값을 읽어오는것처럼 사용하면 된다.Example  skill의 2번째 값을 구하고 싶다json_value = json_data['skill'][1]  이런식으로 간단하게 파싱을 할 수 있다.JSON파일 만들기 Python  Python으로 Json 파일 생성역시 가능하다.import jsonprofile = dict()profile[\"name\"] = \"Sang Hyuk Lee\"profile[\"age\"] = 24profile[\"hobby\"] = [\"soccer\",\"programming\"]with open('./test.json', 'a') as json_file:    json.dump(profile,json_file,indent=\"\\t\")이렇게 하면 JSON파일이 생성이 된다. 마지막 indent=\"\\t\"를 안해주게 되면 위의 내용들이 한줄에 출력되므로 꼭 써주자⭐️주의할 점이 JSON파일은 항상 \"\" 큰따옴표다. 그러므로 항상 큰따옴표로 사용하자//indent=\"\\t\"를 했을 시{\t\"name\": \"Sang Hyuk Lee\",\t\"age\": 24,\t\"hobby\": [\t\t\"soccer\",\t\t\"programming\"\t]}//indent=\"\\t\"를 안했을 시{\"name\": \"Sang Hyuk Lee\", \"age\": 24, \"hobby\": [\"soccer\", \"programming\"]}JSON 파싱 with Java (GSON 설치하기)Java로도 역시 파싱은 가능하다 하지만 기본적으로 java에서 json을 파싱하기 위한 라이브러리는 없으므로 외부에서 가져와야한다. gson을 활용하여 파싱을 해보겠다.여기를 눌러 메이븐 저장소에 접속해준다.여기서 검색창에 gson을 검색하여 첫번째 있는걸 다운로드 해준다. 버전은 왠만하면 최신중에서 Usages가 많은 걸로 한다. 다운로드 완료후 해당 jar 파일을 eclipse에서 외부 라이브러리에 추가를 해준다. 방법은 여기JSON 파싱하기 with Javaimport com.google.gson.JsonArray;import com.google.gson.JsonObject;import com.google.gson.JsonParser;public class JsonParse {\tpublic static void main(String[] args) {\t\tString json=\"{        \\\"name\\\" : \\\"이상혁\\\",         \\\"age\\\" : 24,         \\\"hobby\\\" : \\\"programming\\\",         \\\"job\\\" : \\\"student\\\",         \\\"father\\\" : { \\\"name\\\" : \\\"이00\\\" },         \\\"mother\\\" : { \\\"name\\\" : \\\"김00\\\" },         \\\"sister\\\" : { \\\"name\\\" : \\\"이00\\\" },         \\\"skill\\\" : [\\\"Java\\\",\\\"Python\\\",\\\"Git\\\"]}\";\t\t\t\t\t\tJsonParser jsonParser = new JsonParser();\t\t\t\tJsonObject jsonObject = (JsonObject) jsonParser.parse(json);\t\t\t\tSystem.out.println(jsonObject.get(\"skill\"));\t\tSystem.out.println(jsonObject.get(\"name\"));\t}}  이런식으로 추출이 가능하다. 물론 skill 출력이 가능하다.import com.google.gson.JsonArray;import com.google.gson.JsonObject;import com.google.gson.JsonParser;public class JsonParse {\tpublic static void main(String[] args) {\t\tString json=\"{        \\\"name\\\" : \\\"이상혁\\\",         \\\"age\\\" : 24,         \\\"hobby\\\" : \\\"programming\\\",        \\\"job\\\" : \\\"student\\\",         \\\"father\\\" : { \\\"name\\\" : \\\"이00\\\" },         \\\"mother\\\" : { \\\"name\\\" : \\\"김00\\\" },         \\\"sister\\\" : { \\\"name\\\" : \\\"이00\\\" },         \\\"skill\\\" : [\\\"Java\\\",\\\"Python\\\",\\\"Git\\\"]}\";\t\t\t\t\t\tJsonParser jsonParser = new JsonParser();\t\t\t\tJsonObject jsonObject = (JsonObject) jsonParser.parse(json);\t\t\t\tSystem.out.println(jsonObject.get(\"skill\").getAsJsonArray().get(1));\t\t\t}}  만약 저위에 skill 에서 특정 배열의 위치를 빼고 싶으면 .getAsJsonArray().get(위치); 를 해서 특정 값만 추출도 가능하다.⭐️해당 key값이 객체면 getAsJsonObject 배열 이면 getAsJsonarray 로 추출하면 된다. 배열의 특수번째면 .get(“추출하고 싶은 번째”) 로 추출을 하면 된다.Example{    \"name\" : \"이상혁\",    \"age\" : 24,    \"hobby\" : \"programming\",    \"job\" : \"student\",    \"father\" : {        \"name\" : \"이00\"    },    \"mother\" : {        \"name\" : \"김00\"    },    \"sister\" : {        \"name\" : \"이00\"    },    \"skill\" : [\"Java\",\"Python\",\"Git\"]    }위에서 skill 을 추출하고 싶다 근데 skill은 객체 안에 감싸져 있으므로 skill을 꺼내기 위해선 .getAsJsonObject() 이다skill 안에서 Java를 꺼내고 싶다. Java는 배열 안에 감싸져 있으므로 .getAsJsonArray() 하고 .get(\"번째\") 로 추출을 한다.하지만 위에 코드 예시에선 이미 jsonObject를 선언하고 skill을 추출을 하기 때문에 .getAsJsonObject()는 생략을 한 것이다.출처https://www.json.org/json-ko.htmlhttps://calyfactory.github.io/%EC%A0%9C%EC%9D%B4%EC%8A%A8%ED%8C%8C%EC%8B%B1/https://opentutorials.org/course/1375/6844http://tcpschool.com/json/json_basic_structurehttps://dpdpwl.tistory.com/60https://blog.azulpintor.io/entry/java-extract-value-for-jason-string-by-gson",
        "url": "//%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20tips/2020/01/03/Json-%ED%8C%8C%EC%8B%B1%ED%95%98%EA%B8%B0.html"
      }
      ,
    
      "ed-94-84-eb-a1-9c-ea-b7-b8-eb-9e-98-eb-b0-8d-20tips-2019-12-31-python-queue-eb-aa-a8-eb-93-88-html": {
        "title": "⭐️Python pop()에 관하여, Queue 사용법⭐️",
        "tags": "Python, pop(), Queue, queue",
        "date": "December 31, 2019",
        "author": "",
        "category": "",
        "content": "파이썬 pop() 함수  파이썬의 list나 tuple을 이용하여 큐(queue)를 구현할때 l.pop(0)을 활용하는 경우가 많다. 물론 틀린 방법은 아니지만 효율적이지 않다.  위의 표는 dict 의 pop을 제외시킨 것이다.list의 0번째면 첫번째 인덱스니 l.pop(0)도 O(1)이 맞지 않나? 하는 의문을 갖을 수 있다. 하지만 잘 생각해보면 list나 tuple이나 결국 배열의 형태이다. 첫번째 원소를 없애면 그 공간을 채우기위해서 앞쪽으로 당겨야한다.      앞에 빈 공간을 채우기 위해 list를 한번 다 돌기 때문에 O(N)이라는 시간복잡도가 나온다.        그럼 Queue를 구현하기 위해 가장 좋은 방법은??  Python Queue 모듈  파이썬에 Queue라는 모듈이 존재한다.      우선 사용하기 위해서는 import queue를 사용해야 한다.    queue.Queue(size)          FIFO  Queue 형태의 객체 생성      size에 최대 사이즈를 추가한다.      size를 비워두면 크기는 메모리 범위안에서 무한이다.        queue.LifoQueue(size)          LIFO Stack 형태의 객체 생성      stack은 그냥 list나 tuple에서 pop()으로 구현 가능하므로 패스        queue.PriorityQueue(size)          우선순위 큐 객체를 생성      (priority, value)의 튜플로 입력된다.      priority가 작을수록 높은 순위를 갖는다.      Python Queue 메소드  qsize()          객체의 크기를 반환해준다.        put()          객체에 value를 넣어준다.      Priority Queue는 put(순위,아이템) 이런식으로 사용하면 된다.        get()          큐로 따지면 dequeue를 해주는 메소드        put_nowait()          블로킹 없이 객체에 value를 입력한다.      크기를 지정해줬다면 queue.Full 예외 발생        get_nowait()          블로킹 없이 객체에 value를 반환한다.      객체가 비어있다면 queue.Empty 예외 발생        여기서 블로킹은 큐 크기의 한계에 다다르면 put_nowait()을 사용하지 않고 put()을 사용하면 무한으로 대기한다. 이를 방지하기 위해 put_nowait()을 사용하여 예외 발생시킨다.Python Queue 모듈 사용법Queue 사용법import queueq=queue.Queue()q.put('0')q.put('1')q.put('2')print(q.qsize())print(q.get())print(q.get())print(q.size())'''출력 결과 : 3011'''Priority Queueimport queueq=queue.PriorityQueue()q.put((5,'2'))q.put((10,'3'))q.put((1,'1'))print(q.get())print(q.get())'''출력 결과 : (1, '1')(5, '2')'''출처https://wayhome25.github.io/python/2017/06/14/time-complexity/https://docs.python.org/3/library/queue.htmlhttps://medium.com/@shuangzizuobh2/how-well-do-you-code-python-9bec36bbc322",
        "url": "//%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20tips/2019/12/31/Python-Queue-%EB%AA%A8%EB%93%88.html"
      }
      ,
    
      "ec-95-8c-ea-b3-a0-eb-a6-ac-ec-a6-98-20-eb-9d-bc-ec-9d-b4-eb-b8-8c-eb-9f-ac-eb-a6-ac-2019-12-31-dfs-bfs-html": {
        "title": "BFS 너비 우선 탐색, DFS 깊이 우선 탐색",
        "tags": "DFS, BFS, search, 너비 우선 탐색, 깊이 우선 탐색",
        "date": "December 31, 2019",
        "author": "",
        "category": "",
        "content": "목차    BFS 너비 우선 탐색    BFS 구현 코드    BFS 수행 원리    DFS 깊이 우선 탐색    DFS 구현 코드    DFS 수행 원리BFS(Breadth First Search) 너비 우선 탐색BFS는 그래프에서 사용되는 탐색 기법중 하나다.Queue 자료구조를 사용한다.  BFS 수행 방법  시작 정점 방문한다  정점의 인접 정점중에서 방문하지 않은 정점은 Queue에 저장한다.  Queue를 dequeue하여 그값이 시작 정점이 되고 1을 반복한다.  Queue가 Null이 되면 종료한다.BFS 구현 코드def bfs(graph,start):    visit = {}    q = queue.Queue()    q.put(start)        #q가 존재할때    while q.qsize()&gt;0:        node = q.get()        # 만약 현재 노드의 방문 기록이 없다면 추가        if visit.get(node) == None:            visit[node]=True                # 해당 노드의 인접 노드 큐에 추가        for x in graph[node]:            if visit.get(x) == None:                q.put(x)             ans=[x for x in visit]    return ansBFS 수행 원리 Dequeue는 Queue의 맨앞에 있는 노드를 제거하고 해당 노드를 visit에 추가한다. Dequeue된 노드에 인접 노드가 방문되지 않았다면 Queue에 추가한다. 출력은 다르게 나올 수 있다. 만약 리스트에 B보다 G가 먼저 있다면 G -&gt; B순으로 탐색을 한다.DFS(Depth First Search) 깊이 우선 탐색DFS는 그래프에서 사용되는 탐색 기법중 하나다.Stack 자료구조를 사용한다.  BFS 수행 방법  시작 정점 방문한다  정점의 인접 정점중에서 방문하지 않은 정점은 Stack에 저장한다.  Stack을 pop하여 그 값이 시작 정점이 되고 1을 반복한다.  Stack이 Null이 되면 종료한다.DFS 구현 코드def dfs(graph,start):    visit = {}    s = [start]    #s가 존재할때    while s:        node = s.pop()        if visit.get(node) == None:            visit[node]=True                for x in graph[node]:            if visit.get(x) == None:                s.append(x)            ans = [x for x in visit]    return ansDFS 수행 원리  DFS는 Stack을 이용한다.  Stack이기 때문에 B,G중 맨위에 있는 G를 pop하기 때문에 오른쪽부터 탐색을 시작한다.  만약 왼쪽부터 탐색을 추가하고 싶다면 Stack에 push하는 순서를 바꾸면 된다.참고https://blog.ilkyu.kr/entry/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%84%88%EB%B9%84-%EC%9A%B0%EC%84%A0-%ED%83%90%EC%83%89Breadth-First-Search%EA%B3%BC-%EA%B5%AC%ED%98%84-%EB%B0%A9%EB%B2%95https://kingpodo.tistory.com/48혹시 제가 잘못 알고 있는 부분이나 궁금하신게 있다면 댓글을 남겨주세요! ",
        "url": "//%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC/2019/12/31/dfs_bfs.html"
      }
      ,
    
      "ec-9e-90-eb-a3-8c-ea-b5-ac-ec-a1-b0-20-eb-9d-bc-ec-9d-b4-eb-b8-8c-eb-9f-ac-eb-a6-ac-2019-12-30-graph-html": {
        "title": "자료구조-그래프(Graph)",
        "tags": "자료구조, 그래프, Graph",
        "date": "December 30, 2019",
        "author": "",
        "category": "",
        "content": "목차    그래프란?    그래프 용어    그래프의 특징    그래프, 트리의 차이    그래프 종류    그래프 구현    그래프 탐색그래프란?  그래프는 노드(Node,Vertex)와 간선(Edge,Arc)으로 나타내는 자료구조이다.  그래프는 연결되어 있는 Node 간의 관계를 표현한 자료구조이다.          Ex) 지도, 지하철 노선도, 선수과목, 가족 관계도, 회사 관계도 등      그래프 용어  정점 : Node 혹은 Vertex  간선 : Edge 혹은 Arc  인접 정점 : 간선으로 연결되어 있는 주변 정점  정점의 차수 : 무방향 그래프에서 1개의 정점에 인접한 정점의 수          모든 정점의 차수 = 간선 * 2        진입 차수 : 방향 그래프에서 다른 정점에서 오는 간선의 수  진출 차수 : 방향 그래프에서 다른 정점으로 향하는 간선의 수그래프의 특징  node간의 여러개의 Edge가 존재할 수 있다.  루트,부모-자식 관계의 개념이 없다.  순회는 DFS,BFS로 이루어진다.  순환, 혹은 비순환이다.그래프, 트리의 차이그래프의 종류1.방향그래프 무방향 그래프 (Directed Graph, Undirected Graph)  무방향 그래프          두 노드간 양 방향으로 이동 가능      두 노드를 각각 A,B라 했을때 (A,B)와 (B,A)는 같은 표현이다.        방향 그래프          두 노드간 한 방향으로 이동 가능      두 노드를 각각 A,B라 했을때 (A,B)와 (B,A)는 다른 표현이다.      2. 가중치 그래프(Weighted Graph)  가중치 그래프          간선에 값이 할당된 그래프      ‘네트워크(Network)’라고도 불린다.      출발지-목적지 에서의 신호등, 차량 정체 등에서 활용      3. 완전 그래프(Complete Graph)  모든 노드가 서로 연결되어 있는 그래프  노드가 n이면 간선의 수 : n*(n-1)/2그래프 구현  구현 자체는 너무 쉽다. linkedlist 혹은 array를 활용하여 연결된 리스트를 저장해주면 된다.  위의 그래프를 파이썬의 dict을 이용하여 구현 해보겠다.{0 : [1,2,3,4] , 1 : [0,2,4], 2 : [0,1,3], 3 : [0,2],4 : [0,1]}정말 간단하게 구현 할 수 있다.그래프 탐색1. 깊이 우선 탐색 (Depth First Search(DFS))   자세한 내용은 여기를 참고2. 너비 우선 탐색 (Breadth First Search(BFS))   자세한 내용은 여기를 참고참고https://kamang-it.tistory.com/entry/AlgorithmData-StructureGraph%EA%B7%B8%EB%9E%98%ED%94%84%EC%9D%B4%EB%A1%A0%EA%B3%BC-%EA%B7%B8%EB%9E%98%ED%94%84-%EA%B5%AC%ED%98%84https://www.zerocho.com/category/Algorithm/post/584b9033580277001862f16chttps://gmlwjd9405.github.io/2018/08/13/data-structure-graph.html",
        "url": "//%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%20%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC/2019/12/30/graph.html"
      }
      ,
    
      "eb-b0-b1-ec-97-94-eb-93-9c-2019-12-28-eclipse-html": {
        "title": "Eclipse, Tomcat 연동",
        "tags": "Tomcat, Eclipse, Servlet, http 메소드, http",
        "date": "December 28, 2019",
        "author": "",
        "category": "",
        "content": "목차Eclipse로 web project 만들기Servlet 등록후 구동https 메소드들실행중 에러목록Eclipse로 web project 만들기  우선 Eclipse를 실행 시켜보자  저 창을 닫고 Create a new project를 눌러준다.  여기서 Dynamic Web Project 선택  여기서 가장 중요한건 Target runtime에서 New Runtime을 설정해줘야 하는것이다. New Runtime을 눌러보자  그럼 이렇게 창이 뜨는데 설치한 Tomcat 버전에 맞게 체크 후 Next      Browse로 저번에 설치해준 Tomcat의 directory 누른후 Open! 후 Finish        프로젝트 이름은 자유롭게! 저는 first_web_project로 하겠습니다.    새로운 프로젝트 생성 완료!Servlet 등록후 구동- Servlet 이란?      url 요청을 처리하는 프로그램        new 로 Servlet을 하나 생성한다.        package 이름과 클래스 이름을 자유롭게 생성을 해준다. (단 Java Class 규칙에 의해서 대문자로 구분!)  간단하게 설명하자면 doGet 메소드는 Get으로 오는 요청들을 받아주는 메소드고 doPost는 Post로 오는 요청들을 받아주는 메소드 이다. 그밖에도 doPut 등등 많지만 일단 지금은 doGet만 사용해보자.⭐️http 메서드⭐️  GET          요청된 resource를 조회한다.        POST          요청된 resource를 새롭게 추가한다.        PUT          요청된 resource를 수정한다. (내용 갱신)        DELETE          요청된 resource를 삭제한다.      package examples;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * Servlet implementation class FirstTest */@WebServlet(\"/FirstTest\")public class FirstTest extends HttpServlet {\tprivate static final long serialVersionUID = 1L;           /**     * @see HttpServlet#HttpServlet()     */    public FirstTest() {        super();        // TODO Auto-generated constructor stub    }\t/**\t * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)\t */\tprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\t\tresponse.setContentType(\"text/html;charset=UTF-8\");\t\tPrintWriter out = response.getWriter();\t\tout.print(\"&lt;h1&gt;나는야 상혁!&lt;/h1&gt;\");\t}}간단하게 정리하자면 나는야 상혁! 이라는 내용을 h1으로 감싼 글을 response로 보내준다. 근데 이 내용은 html형식이고 UTF-8형태로 되어 있다. 라는 뜻!실행은 FirstTest.java 에서 Run as 1 Run on Server로 실행을 한다.만약 이런 오류가 뜬다면 여기로 이동!이렇게 간단하게 정말 간단하게 eclipse와 tomcat을 연동해서 원하는 문자 웹사이트에 띄우기 성공!다음 포스팅에선 이렇게 간단한거보단 조금 더 심화된 내용을 다뤄보자!요류 목록오류 내용을 해석해보면 8080,8009 포트가 이미 사용중이다.. 라는 내용이다.보면 8080포트에서 저번에 설치한 톰캣이 구동중이다.. 그럼 localhost:8080에 접속해보자해결 방법은 2가지가 있다.  톰캣 종료  포트 변경우린 1번을 사용하여 해결 해 보겠다.cd ~/apps/apache-tomcat-9.0.30/bin해당 디렉토리로 접속저기서 shutdown.sh 파일을 실행시켜주면 된다.명령어는./shutdown.sh그러면 shutdown이 성공적으로 실행된것을 확인 할 수 있다.혹시 제가 잘못 알고 있거나 오타, 궁금한점 있으시면 댓글 남겨주시면 감사하겠습니다!",
        "url": "//%EB%B0%B1%EC%97%94%EB%93%9C/2019/12/28/Eclipse.html"
      }
      ,
    
      "eb-b0-b1-ec-97-94-eb-93-9c-2019-12-27-java-ec-9b-b9-ea-b0-9c-eb-b0-9c-ed-99-98-ea-b2-bd-ea-b5-ac-ec-b6-95-html": {
        "title": "Java 웹 개발 환경 구축",
        "tags": "Tomcat, Eclipse, JDK, Java, 개발 환경 구축",
        "date": "December 27, 2019",
        "author": "",
        "category": "",
        "content": "목차JDK 설치Eclipse 설치Tomcat 설치JDK 설치  우선 Eclipse에서 자바를 개발을 하려면 개발 환경을 구상해야 된다. 개발 환경을 구상하는 첫번째 단추는 JDK를 설치하는 것이다. 오라클 홈페이지  Java SE(Java Platform Standard Edition)          가장 일반적으로 사용된다.      JDBC나 기본적인 기능이 모두 포함되어 Android 개발을 할 때 주로 SE를 사용한다.        Java EE(Java Platform EnterPrise Edition)          서버측 개발을 위한 플랫폼이다.      기존 SE에서 서버에서 동작하는 분산 멀티미디어를 제공하는 기능을 추가했다.      기존 SE의 기능이 포함된다.        Java ME(Java Platform Micro Edition)          임베디드를 위한 자바 플랫폼이다.      휴대전화, PDA, 세탑 박스에서 자바를 지원하기 위해 만들어진 플랫폼이다.      서버 개발 환경을 구축하므로 EE를 설치하는게 맞지만, 우선은 간단한 웹 서버를 하므로 Java SE를 설치하도록 하자. 추후에 Java EE를 설치하자Accept 를 한후 각자 OS에 맞는 버전을 설치하고 계속 다음을 눌러준다.설치가 완료가 되면 자바 환경 변수를 설정해주자.터미널에 아래와 같이 입력을 해준다.그러면 jdk-13.0.1.jdk 폴더를 확인할 수 있다. 폴더를 확인한 후//bash 쉘이면vi ~/.bash_profile//zsh 쉘이면vi ~/.zshrc에 접속하여JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk-13.0.1.jdk/Contents/Home**jdk-13.0.1.jdk &lt;= 이부분은 사람마다 다를 수 있다.vim에서 이렇게 입력후 esc -&gt; :wq!를 입력 한다. (저장 후 종료)이렇게 뜨면 성공!😊Eclipse 설치      그 다음 Eclipse를 설치를 해보자 설치는 Eclipse 홈페이지에서 할 수 있다.        여기서 파일을 다운로드 받고 설치 파일 실행!        Eclipse IDE for Enterprise Java Developers 버전을 설치해준다.        이유 : 웹 개발을 위해서!!    install을 누른후 쭉 쭉 설치를 해 준다.  이렇게 정상적으로 실행이 되면 성공.TomCat 설치- Apache Tomcat이란?  세계에서 가장 많이 사용되는 WAS(Web Application Server).  자바로 작성된 웹 애플리케이션은 WAS가 있어야 동작.  오픈소스로 누구나 무료로 사용 가능.그럼 설치를 시작 해볼까용Tomcat 홈페이지에 접속하여 Tomcat 9버전 설치Tomcat 9을 클릭.  mac은 tar.gz 다운로드 후 압축해제  윈도우는 zip 일꺼야 아마두~맥북 사용자 기준1mkdir ~/appscd ~/appsmv ~/Downloads/apache-tomcat-9.0.30 ~/apps/위에 명령어를 순서대로 입력해준다.그러면 이렇게 파일이 이동된 것을 확인 할 수 있다.2chmod +x ./bin/*.sh쉘 확장자(.sh)를 가진 파일들에게 실행권한을 준다.쉘 확장자(.sh)파일 권한 부분에 -x 가 있다면 성공../startup.sh실행!localhost:8080 로 접속 했을때 위와 같이 뜨면 Tomcat 설치 return True!혹시 제가 잘못 알고 있거나 오타, 궁금한점 있으시면 댓글 남겨주시면 감사하겠습니다!",
        "url": "//%EB%B0%B1%EC%97%94%EB%93%9C/2019/12/27/Java-%EC%9B%B9-%EA%B0%9C%EB%B0%9C-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%B6%95.html"
      }
      ,
    
      "ec-95-8c-ea-b3-a0-eb-a6-ac-ec-a6-98-20-eb-ac-b8-ec-a0-9c-ed-92-80-ec-9d-b4-2019-12-18-2019-eb-85-84-ec-b9-b4-ec-b9-b4-ec-98-a4-ec-bd-94-eb-94-a9-ed-85-8c-ec-8a-a4-ed-8a-b8-1-eb-b2-88-eb-ac-b8-ec-a0-9c-html": {
        "title": "2019년도 카카오 코딩테스트 오픈 채팅방",
        "tags": "알고리즘 문제, 카카오, 2019카카오",
        "date": "December 18, 2019",
        "author": "",
        "category": "",
        "content": "문제카카오톡 오픈채팅방에서는 친구가 아닌 사람들과 대화를 할 수 있는데, 본래 닉네임이 아닌 가상의 닉네임을 사용하여 채팅방에 들어갈 수 있다.신입사원인 김크루는 카카오톡 오픈 채팅방을 개설한 사람을 위해, 다양한 사람들이 들어오고, 나가는 것을 지켜볼 수 있는 관리자창을 만들기로 했다. 채팅방에 누군가 들어오면 다음 메시지가 출력된다.[닉네임]님이 들어왔습니다.채팅방에서 누군가 나가면 다음 메시지가 출력된다.[닉네임]님이 나갔습니다.채팅방에서 닉네임을 변경하는 방법은 다음과 같이 두 가지이다.    채팅방을 나간 후, 새로운 닉네임으로 다시 들어간다.    채팅방에서 닉네임을 변경한다.닉네임을 변경할 때는 기존에 채팅방에 출력되어 있던 메시지의 닉네임도 전부 변경된다.예를 들어, 채팅방에 Muzi와 Prodo라는 닉네임을 사용하는 사람이 순서대로 들어오면 채팅방에는 다음과 같이 메시지가 출력된다.Muzi님이 들어왔습니다.Prodo님이 들어왔습니다.채팅방에 있던 사람이 나가면 채팅방에는 다음과 같이 메시지가 남는다.Muzi님이 들어왔습니다.Prodo님이 들어왔습니다.Muzi님이 나갔습니다.Muzi가 나간후 다시 들어올 때, Prodo 라는 닉네임으로 들어올 경우 기존에 채팅방에 남아있던 Muzi도 Prodo로 다음과 같이 변경된다.Prodo님이 들어왔습니다.Prodo님이 들어왔습니다.Prodo님이 나갔습니다.Prodo님이 들어왔습니다.채팅방은 중복 닉네임을 허용하기 때문에, 현재 채팅방에는 Prodo라는 닉네임을 사용하는 사람이 두 명이 있다. 이제, 채팅방에 두 번째로 들어왔던 Prodo가 Ryan으로 닉네임을 변경하면 채팅방 메시지는 다음과 같이 변경된다.Prodo님이 들어왔습니다.Ryan님이 들어왔습니다.Prodo님이 나갔습니다.Prodo님이 들어왔습니다.채팅방에 들어오고 나가거나, 닉네임을 변경한 기록이 담긴 문자열 배열 record가 매개변수로 주어질 때, 모든 기록이 처리된 후, 최종적으로 방을 개설한 사람이 보게 되는 메시지를 문자열 배열 형태로 return 하도록 solution 함수를 완성하라.문제링크문제링크제한사항    record는 다음과 같은 문자열이 담긴 배열이며, 길이는 1 이상 100,000 이하이다.    array의 각 원소는 1 이상 100 이하입니다.    commands의 길이는 1 이상 50 이하입니다.    commands의 각 원소는 길이가 3입니다.  예제 입력 1record = [\"Enter uid1234 Muzi\", \"Enter uid4567 Prodo\",\"Leave uid1234\",\"Enter uid1234 Prodo\",\"Change uid4567 Ryan\"]  예제 출력 1result = [\"Prodo님이 들어왔습니다.\", \"Ryan님이 들어왔습니다.\", \"Prodo님이 나갔습니다.\", \"Prodo님이 들어왔습니다.\"]간단한 구현 계획간단히 구현 할 수 있어서 스킵!풀이 with pythondef solution(record):    answer = []    uid={}    temp=[]    for i in record:        tmp=i.split(\" \")        if tmp[0]==\"Enter\":            temp.append(['Enter', tmp[1]])            uid[tmp[1]]=tmp[2]        elif tmp[0]==\"Leave\":            temp.append(['Leave',tmp[1]])        else:            uid[tmp[1]]=tmp[2]    for i in temp:        if i[0]==\"Enter\":            answer.append(uid.get(i[1])+\"님이 들어왔습니다.\")        else:            answer.append(uid.get(i[1])+\"님이 나갔습니다.\")        return answer좀더 나은 풀이def solution(record):    answer = []    namespace = {}    printer = {'Enter':'님이 들어왔습니다.', 'Leave':'님이 나갔습니다.'}    for r in record:        rr = r.split(' ')        if rr[0] in ['Enter', 'Change']:            namespace[rr[1]] = rr[2]    for r in record:        if r.split(' ')[0] != 'Change':            answer.append(namespace[r.split(' ')[1]] + printer[r.split(' ')[0]])    return answer느낀 점카카오 2019년도 1번문제는 생각보다 많이 쉬웠다. 하지만 3번 4번 점점 갈수록 많이 어려워진다. 기본적인거 공부 빨리 끝내고 트리, 그래프 문제들도 풀어봐야겠다.",
        "url": "//%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/2019/12/18/2019%EB%85%84-%EC%B9%B4%EC%B9%B4%EC%98%A4-%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-1%EB%B2%88%EB%AC%B8%EC%A0%9C.html"
      }
      ,
    
      "ec-95-8c-ea-b3-a0-eb-a6-ac-ec-a6-98-20-eb-ac-b8-ec-a0-9c-ed-92-80-ec-9d-b4-2019-12-13-eb-b0-b1-ec-a4-80-9935-eb-ac-b8-ec-9e-90-ec-97-b4-ed-8f-ad-eb-b0-9c-html": {
        "title": "⭐️⭐️백준 9935 문자열 폭발⭐️⭐️",
        "tags": "알고리즘 문제, 백준, 백준9935",
        "date": "December 13, 2019",
        "author": "",
        "category": "",
        "content": "문제상근이는 문자열에 폭발 문자열을 심어 놓았다. 폭발 문자열이 폭발하면 그 문자는 문자열에서 사라지며, 남은 문자열은 합쳐지게 된다.폭발은 다음과 같은 과정으로 진행된다.    문자열이 폭발 문자열을 포함하고 있는 경우에, 모든 폭발 문자열이 폭발하게 된다. 남은 문자열을 순서대로 이어 붙여 새로운 문자열을 만든다.    새로 생긴 문자열에 폭발 문자열이 포함되어 있을 수도 있다.    폭발은 폭발 문자열이 문자열에 없을 때까지 계속된다.상근이는 모든 폭발이 끝난 후에 어떤 문자열이 남는지 구해보려고 한다. 남아있는 문자가 없는 경우가 있다. 이때는 “FRULA”를 출력한다.폭발 문자열은 같은 문자를 두 개 이상 포함하지 않는다.입력첫째 줄에 문자열이 주어진다. 문자열의 길이는 1보다 크거나 같고, 1,000,000보다 작거나 같다.둘째 줄에 폭발 문자열이 주어진다. 길이는 1보다 크거나 같고, 36보다 작거나 같다.두 문자열은 모두 알파벳 소문자와 대문자, 숫자 0, 1, …, 9로만 이루어져 있다.출력첫째 줄에 모든 폭발이 끝난 후 남은 문자열을 출력한다.  예제 입력 1mirkovC4nizCC44C4  예제 출력 1mirkovniz  예제 입력 212ab112ab2ab12ab  예제 출력 2FRULA풀이 with pythontext=input()bomb=input()ans=[]for i in text:    #하나씩 스택에 넣어준다    ans.append(i)    #ans와 bomb의 길이가 같으면    if len(ans)&gt;=len(bomb):        #뒤에서 부터 검사 왜냐하면 앞에서부터 하면 112ab고 12ab일때 일치 하지 않기때문        check = []        checkcount=0        same = True        for j in range(-1,(-len(bomb))-1,-1):            if ans[j] != bomb[j]:                #하나라도 다르면 false                same = False                break                if same == True:            a=0            #bomb의 길이만큼 pop            while a&lt;len(bomb):                ans.pop()                a+=1#길이가 0이면 FRULAif len(ans)==0:    print(\"FRULA\")else:    str=\"\"    for i in ans:        str+=i    print(str)구동원리이런식으로 구동이 된다.유용한 기법for j in range(-1,(-len(bomb))-1,-1)    if ans[j] != bomb[j]:list와 list를 비교 할때 꼭 index 0에서부터 비교할려고 하지 말자. 특수한 경우지만 뒤에서부터 비교를 해야 되는 상황이 올때도 있다는걸 명심하자.어려웠던점우선 앞에서 부터 비교를 할려고 했다. 하지만 bomb이 12ab고 text는 112ab 일때 이때 정말 어떻게 구현할지 고민을 많이 했다. 항상 앞에서 비교를 하자 이 틀 때문에 문제를 어렵게 생각했고 dict을 이용해서 index값을 value로 넣자,, 등 정말 너무 어렵게 풀려고 했다. 하지만 뒤에서 부터 검사하면 정말 쉽게 풀 수 있는 문제였다. 이렇게 스택과 bomb을 비교할때 어떻게 구현하지가 가장 어려웠다.느낀점요 근래 풀었던 문제중에서 가장 어려었던 문제였다. 가장 쉽고 기본적인 구조 스택을 사용하는데 간단한 원리이며 간단한 기술을 사용하는데도 생각해내기엔 다소 어려웠다. 이걸 dict으로 풀려했던 내 모습을 반성하게 된다. 쉽고 간단하지만 생각해내기 어려운 기술들을 이런 문제들을 많이 풀면서 생각해내기 쉽게 만들어야겠다.그리고 너무 어렵게 풀려고 하지말고 쉽게 쉽게 풀려고 하자!",
        "url": "//%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/2019/12/13/%EB%B0%B1%EC%A4%80-9935-%EB%AC%B8%EC%9E%90%EC%97%B4-%ED%8F%AD%EB%B0%9C.html"
      }
      ,
    
      "ec-95-8c-ea-b3-a0-eb-a6-ac-ec-a6-98-20-eb-ac-b8-ec-a0-9c-ed-92-80-ec-9d-b4-2019-12-13-eb-b0-b1-ec-a4-80-1764-eb-93-a3-eb-b3-b4-ec-9e-a1-html": {
        "title": "백준 1764 듣보잡",
        "tags": "알고리즘 문제, 백준, 백준1764",
        "date": "December 13, 2019",
        "author": "",
        "category": "",
        "content": "문제김진영이 듣도 못한 사람의 명단과, 보도 못한 사람의 명단이 주어질 때, 듣도 보도 못한 사람의 명단을 구하는 프로그램을 작성하시오.입력첫째 줄에 듣도 못한 사람의 수 N, 보도 못한 사람의 수 M이 주어진다. 이어서 둘째 줄부터 N개의 줄에 걸쳐 듣도 못한 사람의 이름과, N+2째 줄부터 보도 못한 사람의 이름이 순서대로 주어진다. 이름은 띄어쓰기 없이 영어 소문자로만 이루어지며, 그 길이는 20 이하이다. N, M은 500,000 이하의 자연수이다.출력듣보잡의 수와 그 명단을 사전순으로 출력한다.  예제 입력 13 4ohhenriecharliebaesangwookobamabaesangwookohhenrieclinton  예제 출력 12baesangwookohhenrie간단한 구현 계획dict을 이용하면 쉽게 풀 수 있는 문제라 말로 설명듣도 못한 사람에서key : 이름value : true보도 못한 사람에서 이름이 dict에 있으면 정답 리스트에 추가풀이 with pythontesta,testb = input().split(\" \")ans={}a=[]#듣도 못한사람for i in range(int(testa)):    text=input()    #key는 이름 value는 true    ans[text]=True#보도 못한사람    for i in range(int(testb)):    text=input()    #이미 있는 이름일 때    if ans.get(text)!=None:        #true면 듣도보도 만한 사람        if(ans[text]==True):            a.append(text)    else:        continueprint(len(a))#정렬a.sort()#출력for i in a:    print(i)느낀 점dict의 대단함을 느꼈다. 요번 문제는 dict을 이용하여 쉽게 풀 수 있었다. 패스!",
        "url": "//%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/2019/12/13/%EB%B0%B1%EC%A4%80-1764-%EB%93%A3%EB%B3%B4%EC%9E%A1.html"
      }
      ,
    
      "ec-95-8c-ea-b3-a0-eb-a6-ac-ec-a6-98-20-eb-ac-b8-ec-a0-9c-ed-92-80-ec-9d-b4-2019-12-10-eb-b0-b1-ec-a4-80-java-vs-c-html": {
        "title": "백준 3613 Java vs C++",
        "tags": "알고리즘 문제, 백준, 백준3613",
        "date": "December 10, 2019",
        "author": "",
        "category": "",
        "content": "문제Java 예찬론자 김동규와 C++ 옹호가 김동혁은 서로 어떤 프로그래밍 언어가 최고인지 몇 시간동안 토론을 하곤 했다. 동규는 Java가 명확하고 에러가 적은 프로그램을 만든다고 주장했고, 동혁이는 Java는 프로그램이 느리고, 긴 소스 코드를 갖는 점과 제네릭 배열의 인스턴스화의 무능력을 비웃었다.또, 김동규와 김동혁은 변수 이름을 짓는 방식도 서로 달랐다. Java에서는 변수의 이름이 여러 단어로 이루어져있을 때, 다음과 같은 방법으로 변수명을 짓는다.첫 단어는 소문자로 쓰고, 다음 단어부터는 첫 문자만 대문자로 쓴다. 또, 모든 단어는 붙여쓴다. 따라서 Java의 변수명은 javaIdentifier, longAndMnemonicIdentifier, name, bAEKJOON과 같은 형태이다.반면에 C++에서는 변수명에 소문자만 사용한다. 단어와 단어를 구분하기 위해서 밑줄(‘_‘)을 이용한다. C++ 변수명은 c_identifier, long_and_mnemonic_identifier, name, b_a_e_k_j_o_o_n과 같은 형태이다.이 둘의 싸움을 부질없다고 느낀 재원이는 C++형식의 변수명을 Java형식의 변수명으로, 또는 그 반대로 바꿔주는 프로그램을 만들려고 한다. 각 언어의 변수명 형식의 위의 설명을 따라야 한다.재원이의 프로그램은 가장 먼저 변수명을 입력으로 받은 뒤, 이 변수명이 어떤 언어 형식인지를 알아내야 한다. 그 다음, C++형식이라면 Java형식으로, Java형식이라면 C++형식으로 바꾸면 된다. 만약 C++형식과 Java형식 둘 다 아니라면, 에러를 발생시킨다. 변수명을 변환할 때, 단어의 순서는 유지되어야 한다.재원이는 프로그램을 만들려고 했으나, 너무 귀찮은 나머지 이를 문제를 읽는 사람의 몫으로 맡겨놨다.재원이가 만들려고 한 프로그램을 대신 만들어보자.입력첫째 줄에 변수명이 주어진다. 영어 알파벳과 밑줄(‘_‘)로만 이루어져 있고, 길이는 100을 넘지 않는다.출력입력으로 주어진 변수명이 Java형식이면, C++형식으로 출력하고, C++형식이라면 Java형식으로 출력한다. 둘 다 아니라면 “Error!”를 출력한다.  예제 입력 1long_and_mnemonic_identifier  예제 출력 1longAndMnemonicIdentifier간단한 구현 계획우선 위의 경우대로 하면 실패가 뜬다. 그이유는 “__”을 확인을 안해줬다. 이와 같이 이런 사소한 예외 사항도 잘 고려 해야겠다.풀이 with python#java로 변환def tojava(text):    #첫번째 or 마지막 문자가 _일때 __가 있을때    if text[0] == \"_\" or text[-1] == \"_\" or \"__\" in text:        return \"Error!\"    ans=\"\"    flag=False        for i in text:        #대문자 일때        if ord(i)&gt;=65 and ord(i)&lt;=90:            return \"Error!\"        if i == \"_\":            flag = True            continue        if flag == True:            ans += i.upper()            flag=False            continue        ans+=i    return ans        #c++로 변환def toc(text):    #첫 문자가 대문자 일때    if ord(text[0])&gt;=65 and ord(text[0])&lt;=90:        return \"Error!\"    ans=\"\"    for i in text:        #대문자 일때        if ord(i)&gt;=65 and ord(i)&lt;=90:            ans+=\"_\"+i.lower()        else:            ans+=i    return anstext = input()if \"_\" in text:    print(tojava(text))else:    print(toc(text))Python Skill.lower() # A -&gt; a.upper() # B -&gt; b.ord('a') # 97.chr(97) # a문자열 관련 문제들은 아스키코드를 많이 사용하므로 기본적인 것들은 알아 두면 좋을 것 같다.A - Z = 65~90a - z = 97~122느낀 점문제 자체의 난이도는 높은것 같지 않다. 다만 예외 사항이 생각보다 많아서 정답률이 낮은 것 같다. 2번의 실패 후 성공! 문제를 푸는데 있어서 이러한 예외 사항을 꼼꼼히 잘 따져야겠다. 그리고 파이썬 for문 간편하게!",
        "url": "//%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/2019/12/10/%EB%B0%B1%EC%A4%80-Java-vs-C++.html"
      }
      ,
    
      "ec-95-8c-ea-b3-a0-eb-a6-ac-ec-a6-98-20-eb-ac-b8-ec-a0-9c-ed-92-80-ec-9d-b4-2019-12-08-ed-94-84-eb-a1-9c-ea-b7-b8-eb-9e-98-eb-a8-b8-ec-8a-a4-k-eb-b2-88-ec-a7-b8-ec-88-98-html": {
        "title": "프로그래머스 K번째 수",
        "tags": "알고리즘 문제, 프로그래머스, K번째 수",
        "date": "December 8, 2019",
        "author": "",
        "category": "",
        "content": "문제배열 array의 i번째 숫자부터 j번째 숫자까지 자르고 정렬했을 때, k번째에 있는 수를 구하려 합니다.예를 들어 array가 [1, 5, 2, 6, 3, 7, 4], i = 2, j = 5, k = 3이라면    array의 2번째부터 5번째까지 자르면 [5, 2, 6, 3]입니다.    1에서 나온 배열을 정렬하면 [2, 3, 5, 6]입니다.    2에서 나온 배열의 3번째 숫자는 5입니다.배열 array, [i, j, k]를 원소로 가진 2차원 배열 commands가 매개변수로 주어질 때, commands의 모든 원소에 대해 앞서 설명한 연산을 적용했을 때 나온 결과를 배열에 담아 return 하도록 solution 함수를 작성해주세요.제한사항    array의 길이는 1 이상 100 이하입니다.    array의 각 원소는 1 이상 100 이하입니다.    commands의 길이는 1 이상 50 이하입니다.    commands의 각 원소는 길이가 3입니다.  예제 입력 1array : [1, 5, 2, 6, 3, 7, 4]command : [[2, 5, 3], [4, 4, 1], [1, 7, 3]]  예제 출력 1[5, 6, 3]간단한 구현 계획요번 문제는 정말 쉬워서 계획없이 바로 코드를 짰다.풀이 with pythondef solution(array, commands):    answer = []    for i in commands:        start=i[0]-1        end=i[1]        find=i[2]-1        tmp=array[start:end]        tmp.sort()        answer.append(tmp[find])    return answer고급 개발자의 풀이def solution(array, commands):    return list(map(lambda x:sorted(array[x[0]-1:x[1]])[x[2]-1], commands))정말 머리를 쌔게 한대 맞은 기분이 들었다. 우선 코드가 너무 아름답다. 예술품인거 같다. 2년 안에 이런 예술적인 코드를 짤 수 있기를..느낀 점파이썬의 장점인 for문의 요약, map,  lambda식 많이 정말 많이 부족한것  같다. 파이썬을 쓰면 파이썬답게 간단하게  코드짜는 연습 우선 for문부터 간단하게 짜는 연습하고 lambda, map등 파이썬의 여러 장점을 이용하여 문제를 간단하게 푸는 연습을 하자.",
        "url": "//%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/2019/12/08/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-K%EB%B2%88%EC%A7%B8%EC%88%98.html"
      }
      ,
    
      "ec-95-8c-ea-b3-a0-eb-a6-ac-ec-a6-98-20-eb-ac-b8-ec-a0-9c-ed-92-80-ec-9d-b4-2019-12-07-eb-b0-b1-ec-a4-80-7785-ed-9a-8c-ec-82-ac-ec-97-90-ec-9e-88-eb-8a-94-ec-82-ac-eb-9e-8c-html": {
        "title": "백준 7785 회사에 있는 사람",
        "tags": "알고리즘 문제, 백준, 백준7785",
        "date": "December 7, 2019",
        "author": "",
        "category": "",
        "content": "문제상근이는 세계적인 소프트웨어 회사 기글에서 일한다. 이 회사의 가장 큰 특징은 자유로운 출퇴근 시간이다. 따라서, 직원들은 반드시 9시부터 6시까지 회사에 있지 않아도 된다.각 직원은 자기가 원할 때 출근할 수 있고, 아무때나 퇴근할 수 있다.상근이는 모든 사람의 출입카드 시스템의 로그를 가지고 있다. 이 로그는 어떤 사람이 회사에 들어왔는지, 나갔는지가 기록되어져 있다. 로그가 주어졌을 때, 현재 회사에 있는 모든 사람을 구하는 프로그램을 작성하시오.입력첫째 줄에 로그에 기록된 출입 기록의 수 n이 주어진다. (2 ≤ n ≤ 106) 다음 n개의 줄에는 출입 기록이 순서대로 주어지며, 각 사람의 이름이 주어지고 “enter”나 “leave”가 주어진다. “enter”인 경우는 출근, “leave”인 경우는 퇴근이다.회사에는 동명이인이 없으며, 대소문자가 다른 경우에는 다른 이름이다. 사람들의 이름은 알파벳 대소문자로 구성된 5글자 이하의 문자열이다.출력현재 회사에 있는 사람의 이름을 사전 순의 역순으로 한 줄에 한 명씩 출력한다.  예제 입력 14Baha enterAskar enterBaha leaveArtem enter  예제 출력 1AskarArtem간단한 구현 계획풀이 with python#input 속도 가속을 위해서import sysinput=sys.stdin.readlineworking={}for i in range(int(input())):    text=input().strip().split(\" \")    if text[1] == 'enter':        working[text[0]]=True    elif text[1] == 'leave':        working[text[0]]=Falseans=[]#True인 애들만 모음for i in working:    if working[i]==True:        ans.append(i)#내림차순 정렬ans.sort(reverse=True)for i in ans:    print(i)Python Skillimport sysinput=sys.stdin.readline위에 코드 처럼하면 input 속도가 많이 향상된다고 한다.이유는 링크에서 확인해보자.앞으로 그냥 input()보다는 위 코드처럼 선언하고 사용하는 습관을 들이자.느낀 점이번 문제는 생각보다 어렵지 않았다. 이렇게 dict으로 true와 false를 응용하여 풀어서 쉽게 풀 수 있었다. 비슷한 유형의 문제들도 이렇게 풀면 될것 같다.",
        "url": "//%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/2019/12/07/%EB%B0%B1%EC%A4%80-7785-%ED%9A%8C%EC%82%AC%EC%97%90-%EC%9E%88%EB%8A%94-%EC%82%AC%EB%9E%8C.html"
      }
      ,
    
      "ec-95-8c-ea-b3-a0-eb-a6-ac-ec-a6-98-20-eb-ac-b8-ec-a0-9c-ed-92-80-ec-9d-b4-2019-12-07-eb-b0-b1-ec-a4-80-1213-ed-8c-b0-eb-a6-b0-eb-93-9c-eb-a1-ac-eb-a7-8c-eb-93-a4-ea-b8-b0-html": {
        "title": "백준 1213 팰린드롬 만들기",
        "tags": "알고리즘 문제, 백준, 백준1213",
        "date": "December 7, 2019",
        "author": "",
        "category": "",
        "content": "문제임한수와 임문빈은 서로 사랑하는 사이이다.임한수는 세상에서 팰린드롬인 문자열을 너무 좋아하기 때문에, 둘의 백일을 기념해서 임문빈은 팰린드롬을 선물해주려고 한다.임문빈은 임한수의 영어 이름으로 팰린드롬을 만들려고 하는데, 임한수의 영어 이름의 알파벳 순서를 적절히 바꿔서 팰린드롬을 만들려고 한다.임문빈을 도와 임한수의 영어 이름을 팰린드롬으로 바꾸는 프로그램을 작성하시오.입력첫째 줄에 임한수의 영어 이름이 있다. 알파벳 대문자로만 된 최대 50글자이다.출력첫째 줄에 문제의 정답을 출력한다. 만약 불가능할 때는 “I’m Sorry Hansoo”를 출력한다. 정답이 여러 개일 경우에는 사전순으로 앞서는 것을 출력한다.  예제 입력 1AABB  예제 출력 1ABBA간단한 구현 계획풀이 with pythondef solution(letter):    flag = letter[0] #알파벳 변하는걸 확인    count=1 #알파벳 글자수 새기위한    letter_count=[]    #알파벳 글자수 측정    for i in letter[1:]:#0은 flag이니깐 1부터 검사        if i == flag:#현재 포인터가 flag랑 같으면 알파벳 갯수 +1            count+=1        else:#다르면            letter_count.append([flag,count])#알파벳과 갯수 저장            flag=i #flag값 변동            count=1#개수  초기화    letter_count.append([flag,count])#마지막 알파벳도 저장    letter_count.sort()#알파벳 순으로 정렬    left=[] #팰린드롬 왼쪽 글자    center=[] #팰린드롬 가운데                for i in letter_count:        if i[1]%2==0:#짝수            for j in  range(i[1]//2):                left.append(i[0])        else:#홀수            if(len(center)!=0):                return \"I'm Sorry Hansoo\"#홀수가 2개이상이면            for j in range(i[1]):                center.append(i[0])    #AAABB ==&gt; ABABA 이럴때 하기 위한 것    if len(center)&gt;=3:#center의 길이가 3이상이다        for i in range(len(left)):            if center[0]&lt;left[i]:#left 보다 center의 알파벳이 작으면                left.insert(i,center[0]*int(len(center)//2))#작은곳에 center의 2로 나눈 몫만 추가                center=[center[0]]#센터 초기화    right=left[::-1] #reverse    ans=\"\"    for i in left+center+right:        ans+=i    return ansletter = input()letter_to_list=[]#문자하나하나씩 리스트에 넣어줌for i in letter:    letter_to_list.append(i)letter_to_list.sort()print(solution(letter_to_list))Python Skilla=['a','b','c']b=a[::-1]print(b)출력:[c,b,a]이렇게 슬라이싱을 응용하면 쉽게 reverse를 할 수 있다.어려웠던점입력 : AAABB출력 : BAAAB답 : ABABA포인트 : 정답이 여러 개일 경우에는 사전순으로 앞서는 것을 출력한다.처음 이러한 반례로 문제가 통과 되지 않았다. 반례가 없는 줄 알았지만 반례가 있었다.반례를 찾다가 이러한 반례를 찾았고 center와 left의 원소들을 비교해주고 바꿔주는 코드를 추가했더니 통과가 되었다. 항상 반례 찾는게 가장 어려운것 같다. 반례를 찾는 훈련을 해야겠다느낀점반.례.찾.는.훈.련python으로 코드를 짯지만 뭔가 너무 긴것 같다. 다른 답안의 코드들과 비교했을때 너무 길다. python의 장점을 활용하여 최대한 간결하게 간결하면서도 완벽하게 짜보는걸 연습하자. 다른 사람들의 코드를 많이 보자!",
        "url": "//%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/2019/12/07/%EB%B0%B1%EC%A4%80-1213-%ED%8C%B0%EB%A6%B0%EB%93%9C%EB%A1%AC-%EB%A7%8C%EB%93%A4%EA%B8%B0.html"
      }
      ,
    
      "ec-95-8c-ea-b3-a0-eb-a6-ac-ec-a6-98-20-eb-ac-b8-ec-a0-9c-ed-92-80-ec-9d-b4-2019-12-06-eb-b0-b1-ec-a4-80-5052-ec-a0-84-ed-99-94-eb-b2-88-ed-98-b8-eb-aa-a9-eb-a1-9d-html": {
        "title": "백준 5052 전화번호 목록",
        "tags": "알고리즘 문제, 백준, 백준5052",
        "date": "December 6, 2019",
        "author": "",
        "category": "",
        "content": "문제전화번호 목록이 주어진다. 이때, 이 목록이 일관성이 있는지 없는지를 구하는 프로그램을 작성하시오.전화번호 목록이 일관성을 유지하려면, 한 번호가 다른 번호의 접두어인 경우가 없어야 한다.예를 들어, 전화번호 목록이 아래와 같은 경우를 생각해보자긴급전화: 911상근: 97 625 999선영: 91 12 54 26이 경우에 선영이에게 전화를 걸 수 있는 방법이 없다. 전화기를 들고 선영이 번호의 처음 세 자리를 누르는 순간 바로 긴급전화가 걸리기 때문이다. 따라서, 이 목록은 일관성이 없는 목록이다.입력첫째 줄에 테스트 케이스의 개수 t가 주어진다. (1 ≤ t ≤ 50) 각 테스트 케이스의 첫째 줄에는 전화번호의 수 n이 주어진다. (1 ≤ n ≤ 10000) 다음 n개의 줄에는 목록에 포함되어 있는 전화번호가 하나씩 주어진다. 전화번호의 길이는 길어야 10자리이며, 목록에 있는 두 전화번호가 같은 경우는 없다.출력각 테스트 케이스에 대해서, 일관성 있는 목록인 경우에는 YES, 아닌 경우에는 NO를 출력한다.  예제 입력 12391197625999911254265113123401234401234598346  예제 출력 1NOYES간단한 구현 계획풀이 with pythonimport sysinput=sys.stdin.readlinetestcase=int(input())#테스트케이스def solution(result):    flag=result[0] #비교 대상    for i in result[1:]:        if flag in i[0:len(flag)]:#처음부터 flag값의 길이까지 비교            return \"NO\"        else:            flag=i#flag 값 교체    return \"YES\"ans=[]for i in range(testcase):    result=[]    numofphone=int(input())#전화번호수    for j in range(numofphone):        phonenum=input().rstrip()#전화번호 입력받음        result.append(phonenum)#길이, 번호 순으로 result에 저장    result.sort()#길이순서로 정렬    ans.append(solution(result))#solution 결과를 ans에 푸시!for i in ans:    print(i)느낀점함.수.화어려웠던점처음 풀었을 땐 시간초과가 떴다. 처음엔 모든 값들 다 비교를 해줬다. 하지만 생각해보니 정렬을 해주고 ex[911,9113,9114] 가 되면 어차피 바로 다음꺼에서 NO가 뜨니깐 다 할 필요없이 종료 시키면 된다는걸 꺠달았다. 이상 없을 때 다음값을 flag로 두고 계속해서 넘어가는 코드를 짰더니 통과가 됬다. 이번 문제에서 함수화의 중요성과 정렬의 중요성을 느꼈다.",
        "url": "//%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/2019/12/06/%EB%B0%B1%EC%A4%80-5052-%EC%A0%84%ED%99%94%EB%B2%88%ED%98%B8-%EB%AA%A9%EB%A1%9D.html"
      }
      ,
    
      "ec-95-8c-ea-b3-a0-eb-a6-ac-ec-a6-98-20-eb-ac-b8-ec-a0-9c-ed-92-80-ec-9d-b4-2019-12-04-eb-b0-b1-ec-a4-80-1316-ea-b7-b8-eb-a3-b9-eb-8b-a8-ec-96-b4-ec-b2-b4-ec-bb-a4-html": {
        "title": "백준 1316 그룹 단어 체커",
        "tags": "알고리즘 문제, 백준, 백준1316",
        "date": "December 4, 2019",
        "author": "",
        "category": "",
        "content": "문제그룹 단어란 단어에 존재하는 모든 문자에 대해서, 각 문자가 연속해서 나타나는 경우만을 말한다. 예를 들면, ccazzzzbb는 c, a, z, b가 모두 연속해서 나타나고, kin도 k, i, n이 연속해서 나타나기 때문에 그룹 단어이지만, aabbbccb는 b가 떨어져서 나타나기 때문에 그룹 단어가 아니다.단어 N개를 입력으로 받아 그룹 단어의 개수를 출력하는 프로그램을 작성하시오.입력첫째 줄에 단어의 개수 N이 들어온다. N은 100보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 단어가 들어온다. 단어는 알파벳 소문자로만 되어있고 중복되지 않으며, 길이는 최대 100이다.출력첫째 줄에 그룹 단어의 개수를 출력한다.  예제 입력 13happynewyear  예제 출력 13  예제 입력 24abaabababcabca  예제 출력 21간단한 구현 계획풀이 with python#baekjoon 1316 그룹 단어 체커a = int(input())count=0for i in range(a):#사용자가 원하는 만큼 반복    check = {}    test = input() #단어 입력받고    flag=\"\"    notword=False    for j in test:        if flag!=j: #전 단어와 같지 않으면 flag값을 현재로 바꿈            flag=j            getnum = check.get(j)            if getnum!=None:                notword=True                break            check[j]=1        else:            check[j]=1        if notword==False:        count+=1print(count)새로 알게된 기법NULL어려웠던점요번 문제도 딱히 없었다. for문과 if문만 잘 쓰면 충분히 풀 수 있는 문제다.",
        "url": "//%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/2019/12/04/%EB%B0%B1%EC%A4%80-1316-%EA%B7%B8%EB%A3%B9-%EB%8B%A8%EC%96%B4-%EC%B2%B4%EC%BB%A4.html"
      }
      ,
    
      "ec-95-8c-ea-b3-a0-eb-a6-ac-ec-a6-98-20-eb-ac-b8-ec-a0-9c-ed-92-80-ec-9d-b4-2019-12-04-eb-b0-b1-ec-a4-80-1181-eb-8b-a8-ec-96-b4-ec-a0-95-eb-a0-ac-html": {
        "title": "백준 1181 단어 정렬",
        "tags": "알고리즘 문제, 백준, 백준1181",
        "date": "December 4, 2019",
        "author": "",
        "category": "",
        "content": "문제알파벳 소문자로 이루어진 N개의 단어가 들어오면 아래와 같은 조건에 따라 정렬하는 프로그램을 작성하시오.  길이가 짧은 것부터  길이가 같으면 사전 순으로입력첫째 줄에 단어의 개수 N이 주어진다. (1≤N≤20,000) 둘째 줄부터 N개의 줄에 걸쳐 알파벳 소문자로 이루어진 단어가 한 줄에 하나씩 주어진다. 주어지는 문자열의 길이는 50을 넘지 않는다.출력조건에 따라 정렬하여 단어들을 출력한다. 단, 같은 단어가 여러 번 입력된 경우에는 한 번씩만 출력한다.  예제 입력 113butiwonthesitatenomorenomoreitcannotwaitimyours  예제 출력 1iimitnobutmorewaitwontyourscannothesitate간단한 구현 계획풀이 with pythonletter_count=int(input())letter_list={}def tmp(list_of,a):    #중복확인    if a in list_of != False:        return list_of        list_of.append(a)    list_of.sort()    return list_of for i in range(letter_count):    text=input()    if letter_list.get(len(text)) == None:        letter_list[len(text)]=[text]    else:        a=tmp(letter_list.get(len(text)),text)        letter_list[len(text)]=a#딕셔너리 정렬def f1(x):    return x[0]result = sorted(letter_list.items(),key=f1)for i in result:    for j in i[1]:        print(j)새로 알게된  기법NULL어려웠던점어려웠던 점은 없었다. python 이라서 많이 쉽게 풀 수 있는 문제였던 것 같다.",
        "url": "//%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/2019/12/04/%EB%B0%B1%EC%A4%80-1181-%EB%8B%A8%EC%96%B4-%EC%A0%95%EB%A0%AC.html"
      }
      ,
    
      "ec-95-8c-ea-b3-a0-eb-a6-ac-ec-a6-98-20-eb-ac-b8-ec-a0-9c-ed-92-80-ec-9d-b4-2019-12-03-eb-b0-b1-ec-a4-80-10814-eb-82-98-ec-9d-b4-ec-88-9c-ec-a0-95-eb-a0-ac-html": {
        "title": "백준 10814 나이순 정렬",
        "tags": "알고리즘 문제, 백준, 백준10814",
        "date": "December 3, 2019",
        "author": "",
        "category": "",
        "content": "문제온라인 저지에 가입한 사람들의 나이와 이름이 가입한 순서대로 주어진다. 이때, 회원들을 나이가 증가하는 순으로, 나이가 같으면 먼저 가입한 사람이 앞에 오는 순서로 정렬하는 프로그램을 작성하시오.입력첫째 줄에 회원의 수 N이 주어진다. (1&lt;= N &lt;=100,000)둘째 줄부터 N개의 줄에는 각 회원의 나이와 이름이 공백으로 구분되어 주어진다. 나이는 1보다 크거나 같으며, 200보다 작거나 같은 정수이고, 이름은 알파벳 대소문자로 이루어져 있고, 길이가 100보다 작거나 같은 문자열이다. 입력은 가입한 순서로 주어진다.출력첫째 줄부터 총 N개의 줄에 걸쳐 온라인 저지 회원을 나이 순, 나이가 같으면 가입한 순으로 한 줄에 한 명씩 나이와 이름을 공백으로 구분해 출력한다.  예제 입력 1321 Junkyu21 Dohyun20 Sunyoung  예제 출력 120 Sunyoung21 Junkyu21 Dohyun간단한 구현 계획글씨가 많이 지저분하다.. 글씨체 연습좀 해야겠다.풀이 with pythonloop = int(input())result={}for i in range(loop):#loop번 반복    age,name=input().split(\" \") # 공백 기준으로 2개 입력받음    age=int(age)#a를 정수로 치환    if result.get(age) != None: #같은 나이가 이미 있는 경우        result[age]+=\" \"+name #공백을 포함하여 이름을 넣어줌    else:        result[age]=name#딕셔너리 정렬def f1(x):    return x[0]result = sorted(result.items(),key=f1)ans=[]#정답을 담을 리스트for i in result:    age=0    for j in i:        if isinstance(j,int)==True:#만약 int형이면 나이로 초기화 후 continue            age=j            continue #밑에 코드 실행되는것을 방지        if \" \" in j: #  공백 즉 여러개의 이름이 들어가있는 경우            name=j.split(\" \") #공백을 기준으로 분리 name 리스트에 저장            for k in name:                ans.append(str(age)+\" \"+k)        else:            ans.append(str(age)+\" \"+j)for i in ans:    print(i)새로 알게된 기법python dictionary sortdef f1(x):    return x[0]result = sorted(result.items(),key=f1)코드를 간단하게 설명하자면  result.items()를 하면 딕셔너리의 값들이 tuple 형식으로 출력이된다. key는 어떤 기준점을 잡는  건데 x[0]을 return 해준다. 즉 tuple의 1번째 원소인 key값이 결국엔 sort의 기준이 된다. x[1]을 하면 당연히 value를 기준으로 정렬을 한다.어려웠던점어려웠던 점은 딱히 없었다. 위에 방법 말고도 리스트 자체를 딕셔너리에 넣어서 푸는 방법도 있다. 그럼 패스!",
        "url": "//%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/2019/12/03/%EB%B0%B1%EC%A4%80-10814-%EB%82%98%EC%9D%B4%EC%88%9C-%EC%A0%95%EB%A0%AC.html"
      }
      
    
  };
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.6/lunr.min.js"></script>
<script src="/assets/js/search.js"></script></section>
</article>

    </div>
    


<footer class="site-footer">
	<p class="text">Powered by <a href="https://jekyllrb.com/">Jekyll</a> with <a href="https://github.com/ksshlee/ksshlee.github.io">ksshlee</a>
</p>
</footer>



  </body>
</html>
